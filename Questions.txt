1) Я создаю новую ветку, в нашем калькуляторе. Вопрос: Если я создам новый класс, он отобразится в ветке? Или в ветке, я могу вносить только изменения в класс калькулятор?

Да, если ты создашь новый файл, сделаешь git add, то  git гит начнет отслеживать изменения в нем.

2) Разве не удобнее когда слиянием веток занимается один человек? Или так оно и есть?

Нет, не удобнее. Он бы занимался этим целый день и понадобилась бы отдельная должность- мержильщик. В день на проекте создаются +- 10 мержей
Ты как разработчик ответственен за фичу которую сделал, ее совместимость с кодом в основной ветке и правильное разрешение конфликтов при мерже.
У стороннего челевека уходило бы слишком много времени на разрешение конфликтов и то с большой вероятностью были бы косяки.
Попробуй самостоятельно для еще одной фичи в калькуляторе создать pull request в гитхабе.

3) Верно ли утверждение, что по сути большой разницы между процедурными языками и ОО языками особо нет(кроме методов взаимодействия модулей)? Вся разность в философии и подходе? 
Верно ли, что в процедурном языке, нужно подбирать код под данные, а в ОО языках, данные подбираются под методы?

Я тут вряд ли большой философ) просто хотел, чтобы ты посмотрел как пишутся программы на проц. языках.
В ООП ты можешь обьединить данные (переменные класса) и логику(методы), и фактически создавать свои структуры данных.
В процедурных языках ты оперируешь примитивами и массивами и не можешь обьединить их в одну сущность с даннымиы.

4) Как обновить удаленный репозиторий в папке? git fetch origin, git pull origin, все пробовал, ничего не получается, пришлось clone; 

5) Подскажи пожалуйста, по какому алгоритму ты занимался вначале, что конкретно делал, сколько уделял времени в день и когда вышел на работу? 

6) Приведи пожалуйста несколько примеров задач, которые решаете сейчас на работе, если не трудно и это не тайна.

7) Подскажи пожалуйста, можем ли мы накидать какой то небольшой план по занятиям? Объясню зачем и как я все это вижу:
Случается такое, что я за целый день решаю одну задачу и чуть чуть читаю. Делаю я так потому что не могу расставить приореты, так как не знаю, что нужно, что не нужно. Если это возможно, накатать список того, что я должен знать к концу нашего с тобой обучения, для того что бы выйти на собеседование. Я буду понимать, что и в каком количестве мне нужно делать, что бы например в середине апреля выйти на собеседование или уже написать что нибудь и скинуть резюме на hh, например. 
С этими задачами, не понимаю, сколько тратить на них время. Типо, если я не могу решить задачу в течении 2-х часов то нахер эту задачу. Как то так. Или это не правильно? 

8) Какие есть способы просмотра методов, которые можно применить к классу? Искал методы для работы с массивы и на оракле не нашел то что нужно, в итоге нашел на JR статью которая была полезнее чем вся документация oracle. Может есть еще способы? 

9) Ничего не понимаю, что тут происходит (код из книги). 

    public static void main(String[] args){
        new Person().eat(new Apple());
    }
    static class Person{
        public void eat(Apple apple){
            Apple peeled = apple.getPeeled();
            System.out.println("Yummy");
        }
    }
     static class Peeler{
       static Apple peel(Apple apple){
            return apple;
        }
     }
     
     static class Apple {
        Apple getPeeled(){
            return Peeler.peel(this);
        }
     }


10) Делаю задание на 156 странице. Вызвать второй конструктор из первого с помощью this. Не получается. Получилось только с оператором new. Что не так?

    public static void main(String[] args) {
        Dog dog = new Dog();
    }

    static class Dog{
        Dog(){
            System.out.println("Вызов первого конструктора");
            new Dog(1);
            System.out.println("Вызов 2к из 1к");
        }
        Dog(int i){
            System.out.println("Вызов второго конструктора");
        }

    }

Потому что вызов конструктора из конструктора должен быть первой строкой. 

p161

11) Пытаюсь сделать класс с методом finalize(), но IDEA отмечает его как устаревший..=)

    public static void main(String[] args) {
        Test test = new Test();
    }

    public static class Test{
        Test(){

        }

        public void finalize(){
            System.out.println("Сработал метод finalize()");
        }
    }

"Объясните действие программы". Да ничего не происходит. Я так понимаю, что уборщик мусора, очищает те ячейки памяти, в которых содержатся объекты, которые не используются в программе. То есть: Я написал какой то класс для программы, но потом он мне не понадобился и я не стал его использовать. При выполнении программы уборщик мусора, увидит этот класс и проведет очистку. Но если класс работает в программе (а в моей программе это единственный класс), то и удалять его не стоит. Правильно? 

12)Не понимаю, что делает этот метод, зачем он нужен и тд. Я сначала подумал, что он удаляет какие то классы, которые не используются в программе, но нет. Хрень какая - то, но хочу в ней разобраться. Буду пытаться понять. 

13) Инициализируемый в точке определения - значит что мы создаем ссылку определенного типа и сразу присваиваем ей значение? 
String s = "Hello"; - Инициализация в точке определения? 
Точка определения - объявление переменной. 

String s; 
{...}
s = "Hello"; - Инициализация НЕ в точке определения? 

14) Инициализация класса - есть инициализация его полей? 
По сути - да. 

15) Список аргументов переменной длинны может содержать ноль аргументов. Это может быть полезно при передаче НЕОБЯЗАТЕЛЬНО ЗАВЕРШАЮЩИХ АРГУМЕНТОВ. Что это значит? 
Это значит, что есть аргументы в методе, которые не обязательно передовать. 

16) Класс это некий файл с кодом? Пакет это папка, где хранятся файлы, верно? 

18) Вообще в целом мало что понял про пакеты, надеюсь разберем более подробно. 

19) Помоги пожалуйста разобраться в понятиях: библиотека, пакет, файл, каталог. (все это в контексте главы 6)
 
20) Правильно ли я соорудил отложенную инициализацию? 
public class Main {

    public static void main(String[] args) {
        Test test = Test.getInstance();
    }
}


class Test{
    private static Test instance;

    public static Test getInstance(){
        if(instance==null){
            instance = new Test();
        }
        return instance;
    }
}

Если да, то это какая то странная штука. Зачем мне создавать пустые ссылки? Как метод getInstance(), поможет мне создать объект? Зачем вообще это все, если я могу просто создать объект и дать на него ссылку? Ну а если я забыл указать на что ссылается переменная, то как это мне поможет? Не понимаю. 

21) Чем делегирование отличается от композиции? Правильно ли я понял: Делегирование - когда мы создаем объект супер класса, в новый класс и внутри нашего нового объекта вызываем переопределяем метод, который просто вызывает метод суперкласса?  (Слово супер тут не уместо, так как нет наследования, я понимаю, но решил объяснить так) 


Композиция, это наполнение нового класса, объектами уе существующих классов, однако разве мы не можем использоват их методы? 
Правильно ли я осуществил делегировани? 

Делегирование это то же самое что и Композиция, но методы новог класса называются так же как и методы супер класса. 



23) Конструктор наследуемого класса, должен вызывать конструктор базового в своем конструкторе? 
Если конструткор не дефолтный, то должен!

24) Давай попробуем подробно разобрать код на 218 странице, пожалуйста, меня интересует один вопрос. 

25) " Композиция используется когда в новом классе необходимо задействовать функциональность существующего класса, но не его интерфейс". 
Меня сильно смущает слово "интерфейс" и "функциональность". Функциональность - это способности класса, то есть его методы? А что такое интерфейс класса? (Меня путает слово интерфейс, потому что в джаве, насколько я помню, есть интерфейсы для множественного наследования. А что имеется в виду тут? 

26) Что бы обратиться к внутреннему классу, нужно создать объект внешнего класса? Это правильное утверждение? 

public class Outer {
    class Inner {

    }

    public Inner newInner() {
        return new Inner();
    }
}


public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner in = outer.newInner();
    }
}

Только так, верно? 

27) Что такое класс обертка, простыми словами? Еще со времен JR не могу с этим разобраться

28) Что такое произвольная область действий? 

29) Правильно ли, что объект внутреннего класса, мы можем создать только через метод внешнего класса (который собственно и возвращает нам объект внутреннего класса)?

30) Ничего не понял про замыкание и обратный вызов. Помоги пожалуйста разобраться.

31)"Если порядок хранения для вас важен, используется TreeSet, который хранит объекты в порядке их ВОЗРАСТАНИЯ". Что значит "Порядок возрастания объектов?".

32) "Так как объекты String не модифицируются, в прогромме можно создать сколько угодно "синонимов". Что такое синонимы (в контексте String, конечно же).

33) Зачем создавать отдельный метод для проверки вводимых данных, если можно считать с консоли и одновременно проверить, верные ли данные ввел пользователь? 

34) Совсем ничего не понял про квантификаторы. 

35) Интерфейс CharSequence - устанавливает обобщенное определение последовательности символов.. ??:)

36) "Альтернативный метод compile() получает ФЛАГИ???? управляющие процессом поиска совпадений. Видимо я должен знать что такое флаги, но я понятия не имею что это. 

37) Можем ли мы подробнее разобрать "загрузчики классов"? JVM создает объект класса Class, на каждый мой класс? Цепочка загрузчиков? Первичный загрузчик классов? 

38) Такая путаница в голове. Он создает класс Class, для создания новых классов? Я ничего не понимаю. 

39) Параметризация. Зачем параметризация нужна у контейнеров, я понимаю. Однако, не до конца понимаю зачем она нужна у классов. Например у нас есть класс Dog extends Pet, и есть класс AnimalHome. Мы хотим что бы класс AnimalHome, работал и с Dog и с Pet одинаково, к классу AnimalHome, мы добавляем <T> и у нас все работает? А почему полиморфизм тут не работает? Что вообще за сущность это T? Просто показываем jav'е, что мол вот, мы тут можем хранить что угодно? 

40) Кортежи. 

class TwoTuple<A,B>{
    public final A first;
    public final B second;

    TwoTuple(A a, B b) {
        this.first = a;
        this.second = b;
    }

    @Override
    public String toString(){
        return String.valueOf(first +" "+ second);
    }
}

Я тут немного повозился с примером из книги и у меня несколько вопросов: 
 а) A,B выступают тут в роли заменителя слово Object? Раз мы не можем написать в <Object, Object>, вместо этого мы пишем A,B? Ведь по сути так есть. Или я не прав? 

 б) Раз это заменить Object, я решил переписать код так: 
class TwoTuple{

    Object object1;
    Object object2;

    TwoTuple(Object object1, Object object2) {
        this.object1 = object1;
        this.object2 = object2;
    }

    @Override
    public String toString(){
        return String.valueOf(object1 +" "+ object2);
    }
}

И тоже все работает. Так зачем нужны эти усложнения с обобщаемыми типами для классов, если можно написать и так? 

41) По всей видимости, вместо <T>, Можно подставлять разные классы, которые нам нужны, верно? Но что именно мы сообщаем добавляем данную конструкцию? Класс может содержать в себе любой класс и рабоать с ним? 

42) Задание №4 на странице 523, не получается сделать. Я как бы понимаю, что нам нужно воспользоваться полиморфизмом, но не понимаю как. У класса EnumSet есть метод clone, как и у object'a, и нам надо сделать так, что бы метод работал и с EnumSet'ами и с Set'aми. Я пытался по всякому воспользоваться полиморфизмом, но у меня не получается что - то.

43) Анонимный класс - это по сути анонимный объект? Просто странно, что это называется анонимный класс. Скорее всего это тупой вопрос, но меня почему то это заинтересовало

44) Пример на 527 странице. Откуда взялись эти буквы при выводе на экран? Это что то значит? 

45) Абзац на 528 странице про стирания. "List<Integer> и List<String>, во время выполнения по сути являются одним типом". Я попытался проверить это, однако у меня не получилось. Это идея такая умная, или я что то не так понял? 

        List <Integer> integerList = new ArrayList<>();
        List <String> stringList = new ArrayList<>();

        integerList.add(1);
        stringList.add("Hello");

        integerList.add(stringList.get(0)); <--- вот тут ошибка, хотя если компьютер думает, что это один тип, он должен выполнить команду, разве нет? Или "Во время выполнения" это не то что я думаю?

46) Итак что же значит стирание? Что во время выполнения <T> заменяется на нечто несуществующее или Object? И Если это так почему нельзя просто использовать <Object> вместо <T>? 

47) Тупой Эккель (простите за гнев), дал определение стиранию только на 31 странице данной главы. "Обобщенный тип стирается то есть заменяется необобщенным верхним ограничителем". 

48) Вакансии которые ты скинул, к сожалению не дают тестов, надо просто откликаться =(  Но я просто прошел 2 теста из инета, один сдал на 15/17, второй 27/30. Пишут что я молодец, ахахахха, но вопросы максимально лайтовые были, на собеседовании бы так

49) Анонимный класс - объект интерфейса созданный для того что бы реализовать метод данного интерфейса, так? 

50) 