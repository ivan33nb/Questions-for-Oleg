1) Я создаю новую ветку, в нашем калькуляторе. Вопрос: Если я создам новый класс, он отобразится в ветке? Или в ветке, я могу вносить только изменения в класс калькулятор?

Да, если ты создашь новый файл, сделаешь git add, то  git гит начнет отслеживать изменения в нем.

2) Разве не удобнее когда слиянием веток занимается один человек? Или так оно и есть?

Нет, не удобнее. Он бы занимался этим целый день и понадобилась бы отдельная должность- мержильщик. В день на проекте создаются +- 10 мержей
Ты как разработчик ответственен за фичу которую сделал, ее совместимость с кодом в основной ветке и правильное разрешение конфликтов при мерже.
У стороннего челевека уходило бы слишком много времени на разрешение конфликтов и то с большой вероятностью были бы косяки.
Попробуй самостоятельно для еще одной фичи в калькуляторе создать pull request в гитхабе.

3) Верно ли утверждение, что по сути большой разницы между процедурными языками и ОО языками особо нет(кроме методов взаимодействия модулей)? Вся разность в философии и подходе? 
Верно ли, что в процедурном языке, нужно подбирать код под данные, а в ОО языках, данные подбираются под методы?

Я тут вряд ли большой философ) просто хотел, чтобы ты посмотрел как пишутся программы на проц. языках.
В ООП ты можешь обьединить данные (переменные класса) и логику(методы), и фактически создавать свои структуры данных.
В процедурных языках ты оперируешь примитивами и массивами и не можешь обьединить их в одну сущность с даннымиы.

4) Как обновить удаленный репозиторий в папке? git fetch origin, git pull origin, все пробовал, ничего не получается, пришлось clone; 

5) Подскажи пожалуйста, по какому алгоритму ты занимался вначале, что конкретно делал, сколько уделял времени в день и когда вышел на работу? 

6) Приведи пожалуйста несколько примеров задач, которые решаете сейчас на работе, если не трудно и это не тайна.

7) Подскажи пожалуйста, можем ли мы накидать какой то небольшой план по занятиям? Объясню зачем и как я все это вижу:
Случается такое, что я за целый день решаю одну задачу и чуть чуть читаю. Делаю я так потому что не могу расставить приореты, так как не знаю, что нужно, что не нужно. Если это возможно, накатать список того, что я должен знать к концу нашего с тобой обучения, для того что бы выйти на собеседование. Я буду понимать, что и в каком количестве мне нужно делать, что бы например в середине апреля выйти на собеседование или уже написать что нибудь и скинуть резюме на hh, например. 
С этими задачами, не понимаю, сколько тратить на них время. Типо, если я не могу решить задачу в течении 2-х часов то нахер эту задачу. Как то так. Или это не правильно? 

8) Какие есть способы просмотра методов, которые можно применить к классу? Искал методы для работы с массивы и на оракле не нашел то что нужно, в итоге нашел на JR статью которая была полезнее чем вся документация oracle. Может есть еще способы? 

9) Ничего не понимаю, что тут происходит (код из книги). 

    public static void main(String[] args){
        new Person().eat(new Apple());
    }
    static class Person{
        public void eat(Apple apple){
            Apple peeled = apple.getPeeled();
            System.out.println("Yummy");
        }
    }
     static class Peeler{
       static Apple peel(Apple apple){
            return apple;
        }
     }
     
     static class Apple {
        Apple getPeeled(){
            return Peeler.peel(this);
        }
     }


10) Делаю задание на 156 странице. Вызвать второй конструктор из первого с помощью this. Не получается. Получилось только с оператором new. Что не так?

    public static void main(String[] args) {
        Dog dog = new Dog();
    }

    static class Dog{
        Dog(){
            System.out.println("Вызов первого конструктора");
            new Dog(1);
            System.out.println("Вызов 2к из 1к");
        }
        Dog(int i){
            System.out.println("Вызов второго конструктора");
        }

    }

Потому что вызов конструктора из конструктора должен быть первой строкой. 

p161

11) Пытаюсь сделать класс с методом finalize(), но IDEA отмечает его как устаревший..=)

    public static void main(String[] args) {
        Test test = new Test();
    }

    public static class Test{
        Test(){

        }

        public void finalize(){
            System.out.println("Сработал метод finalize()");
        }
    }

"Объясните действие программы". Да ничего не происходит. Я так понимаю, что уборщик мусора, очищает те ячейки памяти, в которых содержатся объекты, которые не используются в программе. То есть: Я написал какой то класс для программы, но потом он мне не понадобился и я не стал его использовать. При выполнении программы уборщик мусора, увидит этот класс и проведет очистку. Но если класс работает в программе (а в моей программе это единственный класс), то и удалять его не стоит. Правильно? 

12)Не понимаю, что делает этот метод, зачем он нужен и тд. Я сначала подумал, что он удаляет какие то классы, которые не используются в программе, но нет. Хрень какая - то, но хочу в ней разобраться. Буду пытаться понять. 

13) Инициализируемый в точке определения - значит что мы создаем ссылку определенного типа и сразу присваиваем ей значение? 
String s = "Hello"; - Инициализация в точке определения? 
Точка определения - объявление переменной. 

String s; 
{...}
s = "Hello"; - Инициализация НЕ в точке определения? 

14) Инициализация класса - есть инициализация его полей? 
По сути - да. 

15) Список аргументов переменной длинны может содержать ноль аргументов. Это может быть полезно при передаче НЕОБЯЗАТЕЛЬНО ЗАВЕРШАЮЩИХ АРГУМЕНТОВ. Что это значит? 
Это значит, что есть аргументы в методе, которые не обязательно передовать. 

16) Класс это некий файл с кодом? Пакет это папка, где хранятся файлы, верно? 

18) Вообще в целом мало что понял про пакеты, надеюсь разберем более подробно. 

19) Помоги пожалуйста разобраться в понятиях: библиотека, пакет, файл, каталог. (все это в контексте главы 6)
 
20) Правильно ли я соорудил отложенную инициализацию? 
public class Main {

    public static void main(String[] args) {
        Test test = Test.getInstance();
    }
}


class Test{
    private static Test instance;

    public static Test getInstance(){
        if(instance==null){
            instance = new Test();
        }
        return instance;
    }
}

Если да, то это какая то странная штука. Зачем мне создавать пустые ссылки? Как метод getInstance(), поможет мне создать объект? Зачем вообще это все, если я могу просто создать объект и дать на него ссылку? Ну а если я забыл указать на что ссылается переменная, то как это мне поможет? Не понимаю. 

21) Чем делегирование отличается от композиции? Правильно ли я понял: Делегирование - когда мы создаем объект супер класса, в новый класс и внутри нашего нового объекта вызываем переопределяем метод, который просто вызывает метод суперкласса?  (Слово супер тут не уместо, так как нет наследования, я понимаю, но решил объяснить так) 


Композиция, это наполнение нового класса, объектами уе существующих классов, однако разве мы не можем использоват их методы? 
Правильно ли я осуществил делегировани? 

Делегирование это то же самое что и Композиция, но методы новог класса называются так же как и методы супер класса. 



23) Конструктор наследуемого класса, должен вызывать конструктор базового в своем конструкторе? 
Если конструткор не дефолтный, то должен!

24) Давай попробуем подробно разобрать код на 218 странице, пожалуйста, меня интересует один вопрос. 

25) " Композиция используется когда в новом классе необходимо задействовать функциональность существующего класса, но не его интерфейс". 
Меня сильно смущает слово "интерфейс" и "функциональность". Функциональность - это способности класса, то есть его методы? А что такое интерфейс класса? (Меня путает слово интерфейс, потому что в джаве, насколько я помню, есть интерфейсы для множественного наследования. А что имеется в виду тут? 

26) Что бы обратиться к внутреннему классу, нужно создать объект внешнего класса? Это правильное утверждение? 

public class Outer {
    class Inner {

    }

    public Inner newInner() {
        return new Inner();
    }
}


public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner in = outer.newInner();
    }
}

Только так, верно? 

27) Что такое класс обертка, простыми словами? Еще со времен JR не могу с этим разобраться

28) Что такое произвольная область действий? 
